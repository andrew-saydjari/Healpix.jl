var documenterSearchIndex = {"docs":
[{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"DocTestSetup = quote\n    using Healpix\nend","category":"page"},{"location":"alm/#Spherical-harmonics","page":"Spherical harmonics","title":"Spherical harmonics","text":"","category":"section"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"Starting from version 2.4, Healpix.jl implements generalized Fourier transformations through the libsharp library, to convert a map from its pixel-space representation to its decomposition in spherical harmonics. This has multiple applications, the most relevant being the analysis of Cosmic Microwave Background maps and the efficient computation of convolution operators.","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"Everything revolves around the Alm type, which encodes a set of spherical harmonics and is thus conceptually equivalent to the concept of a Map, only living in the harmonic space:","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"Alm","category":"page"},{"location":"alm/#Healpix.Alm","page":"Spherical harmonics","title":"Healpix.Alm","text":"An array of harmonic coefficients (a_ℓm).\n\nThe type T is used for the value of each harmonic coefficient, and it must be a Number (one should however only use complex types for this). The type AA is used to store the array of coefficients; a typical choice is Vector.\n\nA Alm type contains the following fields:\n\nalm: the array of harmonic coefficients\nlmax: the maximum value for ℓ\nmmax: the maximum value for m\ntval: maximum number of m coefficients for the maximum ℓ\n\n\n\n\n\n","category":"type"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"In the general case, the number of coefficients in a spherical harmonic expansion is infinite. For obvious reasons, Healpix.jl only allows to store band-limited expansions. The function numberOfAlms returns the number of floating-point numbers used to store the expansion, as a function of the maximum value for ell and m.","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"numberOfAlms","category":"page"},{"location":"alm/#Healpix.numberOfAlms","page":"Spherical harmonics","title":"Healpix.numberOfAlms","text":"numberOfAlms(lmax::Integer, mmax::Integer) -> Integer\nnumberOfAlms(lmax::Integer) -> Integer\n\nReturn the size of the array of complex numbers needed to store the a_lm coefficients in the range of ℓ and m specified by lmax and mmax. If mmax is not specified, it is assumed to be equal to lmax. If lmax and mmax are inconsistent or negative, a DomainError exception is thrown.\n\n\n\n\n\n","category":"function"},{"location":"alm/#Converting-between-pixel-space-and-harmonic-space","page":"Spherical harmonics","title":"Converting between pixel space and harmonic space","text":"","category":"section"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"Healpix.jl implements the four functions alm2map, map2alm, alm2map!, and map2alm! to convert a map from a pixel-space representation to the harmonic space and vice-versa. The functions ending with ! are mutating functions, which means that they assume that the result must be saved in a preallocated variable; they are space- and time-efficient and should be used when you want your code to be performant, or when you plan to apply the same operation several times (e.g., in a Monte Carlo simulation).","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"Here is an example:","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"using Healpix # hide\nusing Random\n\n# Ensure reproducibility by using a fixed seed\nRandom.seed!(1234)\n\nnside = 8\nm = Map{Float32,RingOrder}(nside)\n\n# Initialize the pixels to random values in the 0…1 range\nfor i in 1:length(m)\n    m[i] = rand(Float32)\nend\n\nalm = map2alm(m)\n\n# Go back to pixel space\nnewm = alm2map(alm, nside)","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"The variable newm is a map that is close enough to m, yet it is not exactly the same because of the approximations done by both map2alm and alm2map.","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"map2alm!\nmap2alm\nalm2map!\nalm2map","category":"page"},{"location":"alm/#Healpix.map2alm!","page":"Spherical harmonics","title":"Healpix.map2alm!","text":"map2alm!(map::Map{Float64, RingOrder, Array{Float64, 1}}, alm::Alm{ComplexF64, Array{ComplexF64, 1}}; niter::Integer=3)\nmap2alm!(map::PolarizedMap{Float64, RingOrder, Array{Float64, 1}}, alm::Array{Alm{ComplexF64, Array{ComplexF64, 1}},1};\n    niter::Integer=3)\n\nThis function performs a spherical harmonic transform on the map and places the results in the passed alm object. This function requires types derived from Float64, since it is done in-place.\n\nArguments\n\nmap: the map that must be decomposed in spherical harmonics. It can either be a Map{Float64, RingOrder} type (scalar map) or a PolarizedMap{Float64, RingOrder} type (polarized map).\nalm::Alm{ComplexF64, Array{ComplexF64, 1}}: the spherical harmonic coefficients to be written to.\n\nKeywords\n\nniter::Integer: number of iterations of SHTs to perform, to enhance accuracy\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.map2alm","page":"Spherical harmonics","title":"Healpix.map2alm","text":"map2alm(map::Map{Float64, RingOrder, AA};\n    lmax=nothing, mmax=nothing, niter::Integer=3)\nmap2alm(m::Map{T, RingOrder, AA}; lmax=nothing, mmax=nothing,\n    niter::Integer=3) where {T <: Real, AA <: AbstractArray{T, 1} }\n\nCompute the spherical harmonic coefficients of a map. To enhance precision, more iterations of the transforms can be performed by passing a nonzero niter. The underlying SHT library libsharp performs all calculations using Cdouble types, so all inputs are converted to types based on Float64.\n\nArguments\n\nmap: the map to decompose in spherical harmonics. It can either be a Map{T, RingOrder, AA} type (scalar map) or a PolarizedMap{T, RingOrder, AA} type (polarized map).\n\nKeywords\n\nlmax::Integer: the maximum ℓ coefficient, will default to 3*nside-1 if not specified.\nmmax::Integer: the maximum m coefficient\nniter::Integer: number of SHT iterations, to enhance precision. Defaults to 3\n\nReturns\n\nAlm{ComplexF64, Array{ComplexF64, 1}}: the spherical harmonic coefficients corresponding to the map\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.alm2map!","page":"Spherical harmonics","title":"Healpix.alm2map!","text":"alm2map!(alm::Alm{ComplexF64, Array{ComplexF64, 1}}, map::Map{Float64, RingOrder, Array{Float64, 1}})\nalm2map!(alm::Array{Alm{ComplexF64, Array{ComplexF64, 1}},1}, map::PolarizedMap{Float64, RingOrder, Array{Float64, 1}})\n\nThis function performs a spherical harmonic transform on the map and places the results in the passed alm object. This function requires types derived from Float64, since it is done in-place.\n\nArguments\n\nalm::Alm{ComplexF64, Array{ComplexF64, 1}}: the spherical harmonic coefficients to perform the spherical harmonic transform on.\nmap: the map that will contain the result. It can either be a Map{Float64, RingOrder, Array{Float64, 1}} type (scalar map) or a PolarizedMap{Float64, RingOrder, Array{Float64, 1}} (polarized map).\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.alm2map","page":"Spherical harmonics","title":"Healpix.alm2map","text":"alm2map(alm::Alm{ComplexF64, Array{Float64, 1}}, nside::Integer)\nalm2map(alm::Alm{T, Array{T, 1}}, nside::Integer) where T\nalm2map(alm::Array{Alm{ComplexF64, Array{ComplexF64, 1}},1}, nside::Integer)\nalm2map(alms::Array{Alm{T, Array{T, 1}},1}, nside::Integer) where T\n\nCompute a map from spherical harmonic coefficients. The underlying SHT library libsharp performs all calculations in Cdouble, so all inputs are converted to types based on Float64.\n\nArguments\n\nalm: the spherical harmonic coefficients to transform. If of type Alm{T, Array{T, 1}}, we assume a spin-0 spherical harmonic transform. If an array of Alm is passed, we assume that the components correspond to T, E, and B coefficients.\n\nKeywords\n\nnside::Integer: Healpix resolution parameter\n\nReturns\n\nMap{Float64, RingOrder, Array{Float64, 1}} or PolarizedMap{Float64, RingOrder, Array{Float64, 1}} depending on if the input alm is of type Alm{T, Array{T, 1}} or Array{Alm{T, Array{T, 1}}} respectively.\n\n\n\n\n\n","category":"function"},{"location":"alm/#From-harmonic-coefficients-to-the-power-spectrum","page":"Spherical harmonics","title":"From harmonic coefficients to the power spectrum","text":"","category":"section"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"You can use the function alm2cl to convert a set of a_ell m coefficients into the components C_ell of the power spectrum.  The pixelization also induces a transfer function, which can be obtained from pixwin.","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"alm2cl\npixwin","category":"page"},{"location":"alm/#Healpix.alm2cl","page":"Spherical harmonics","title":"Healpix.alm2cl","text":"alm2cl(alm::Alm{Complex{T}}) where {T <: Number}\nalm2cl(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T <: Number}\n\nCompute C_ell from the spherical harmonic coefficients of one or two fields.\n\nArguments\n\nalm₁::Alm{Complex{T}}: the spherical harmonic coefficients of the first field\nalm₂::Alm{Complex{T}}: the spherical harmonic coefficients of the second field\n\nReturns\n\nArray{T} containing C_{\u001bll}, with the first element referring to ℓ=0.\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.pixwin","page":"Spherical harmonics","title":"Healpix.pixwin","text":"pixwin(nside; pol=false)\n\nArguments:\n\nnside: HEALPix resolution parameter\n\nKeywords\n\npol::Bool=false: if true, also return polarization pixel window\n\nReturns:\n\nVector{Float64} pixel window function. If pol=true, returns a Tuple   of the temperature and polarization pixel windows.\n\nExamples\n\njulia> pixwin(4)\n17-element Vector{Float64}:\n 1.0000000000020606\n 0.9942340766588788\n ⋮\n 0.4222841034207188\n\n\n\n\n\n","category":"function"},{"location":"alm/#Loading-and-saving-harmonic-coefficients","page":"Spherical harmonics","title":"Loading and saving harmonic coefficients","text":"","category":"section"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"readAlmFromFITS","category":"page"},{"location":"alm/#Healpix.readAlmFromFITS","page":"Spherical harmonics","title":"Healpix.readAlmFromFITS","text":"readAlmFromFITS{T <: Complex}(f::FITSIO.FITSFile, t::Type{T}) -> Alm{T}\nreadAlmFromFITS{T <: Complex}(fileName::String, t::Type{T}) -> Alm{T}\n\nRead a set of a_ℓm coefficients from a FITS file. If the code fails, FITSIO will raise an exception. (Refer to the FITSIO library for more information.)\n\n\n\n\n\n","category":"function"},{"location":"alm/#Full-Pixel-Weights","page":"Spherical harmonics","title":"Full Pixel Weights","text":"","category":"section"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"The default map2alm uses iteration to obtain an accurate transform. One can instead apply a pixel weight to compute an accurate transform in a single pass, like quadrature. The easiest way to the pixel weight files is to run","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"git clone --depth 1 https://github.com/healpy/healpy-data","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"These weights are in a compressed format that is read with readfullweights and multiplied into a map with applyweights!. ","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"nside = 32\ncompressed_weights = Healpix.readfullweights(\n    \"healpix_full_weights_nside_$(lpad(nside,4,'0')).fits\")\nm = Healpix.Map{Float64,Healpix.RingOrder}(ones(Healpix.nside2npix(nside)))\nHealpix.applyweights!(m, compressed_weights)\nalm = Healpix.map2alm(m; niter=0)","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"The subsequent map2alm only needs niter=0.","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"Healpix.readfullweights\nHealpix.applyweights!","category":"page"},{"location":"alm/#Healpix.readfullweights","page":"Spherical harmonics","title":"Healpix.readfullweights","text":"readfullweights(filename::String)\n\nThe easiest way to the pixel weight files is to run\n\ngit clone --depth 1 https://github.com/healpy/healpy-data\n\nArguments:\n\nfilename::String: filename of the full pixel weights\n\nReturns:\n\nVector{Float64}: contains the compressed pixel weights\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.applyweights!","page":"Spherical harmonics","title":"Healpix.applyweights!","text":"applyweights!(m::Map{T, RingOrder}, wgt::Vector{T}) where T\n\nApply a pixel weighting to a map for more accurate SHTs. Note that  this only helps for lmax<=1.5*Nside. If this is not the case, the  pixel weights may do more harm than good.\n\nArguments:\n\nm::Map{T, RingOrder}: map to modify\nwgt::Vector{T}: compressed pixel weights\n\n\n\n\n\napplyweights!(m::PolarizedMap{T, RingOrder}, wgt::Vector{T}) where T\n\nApply a pixel weighting to a polarized map for more accurate SHTs.\n\nArguments:\n\nm::PolarizedMap{T, RingOrder}: map to modify\nwgt::Vector{T}: compressed pixel weights\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"DocTestSetup = quote\n    using Healpix\nend","category":"page"},{"location":"mapfunc/#Map-functions","page":"Map functions","title":"Map functions","text":"","category":"section"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Functions like pix2angNest and ang2pixNest fully define the Healpix tessellation scheme. They are however extremely impractical in a number of situations. It happens often that a large fraction of pixels in a map need to be processed together. Healpix.jl introduces the Map{T, O <: Order} type, which acts as a collection of all the pixels on the sphere. A Map type holds the value of all the pixels in its pixels field, and it keeps track of the ordering (either RING or NESTED). Here is an example that shows how to create a map and initialize it:","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"nside = 32\nm = Map{Float64, RingOrder}(nside)\nm.pixels[:] = 1.0  # Set all pixels to 1","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Healpix.jl defines the basic operations on maps (sum, subtraction, multiplication, division). These operations can either combine two maps or a map and a scalar value:","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"mollweide(m * 2.0)\nmollweide(m * m)","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"The Map{T, O <: Order} is derived from the abstract type GenericMap{T}, which does not encode the ordering. It is useful for functions that can either work on ring/nested-ordered maps but cannot be executed on plain generic arrays:","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"# Return the number of pixels in the map, regardless of its ordering\nmaplength(m::GenericMap{T}) where T = length(m)\n\n# This returns 12\nmaplength(Map{Float64, RingOrder}(1))\n\n# This too returns 12\nmaplength(Map{Float64, NestedOrder}(1))\n\n# This fails\nmaplength(zeros(Float64, 12))","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Healpix.jl implements the PolarizedMap{T, O <: Order} type as well. This encodes three maps containing the I/Q/U signal: the intensity (I), and the Q and U Stokes parameters. The three maps must have the same resolution.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"GenericMap\nMap\nPolarizedMap","category":"page"},{"location":"mapfunc/#Healpix.GenericMap","page":"Map functions","title":"Healpix.GenericMap","text":"GenericMap{T} <: AbstractArray{T, 1}\n\nAn abstract type representing an Healpix map without a specified ordering. This can be used to implement multiple dispatch when you don't care about the ordering of a map.\n\n\n\n\n\n","category":"type"},{"location":"mapfunc/#Healpix.Map","page":"Map functions","title":"Healpix.Map","text":"struct Map{T, O <: Order, AA <: AbstractArray{T, 1}} <: GenericMap{T}\n\nA Healpix map. The type T is used for the value of the pixels in a map, and it can be anything (even a string!). The type O is used to specify the ordering of the pixels, and it can either be RingOrder or NestedOrder. The type AA is used to store the array of pixels; typical types are Vector, CUArray, SharedArray, etc.\n\nA Map type contains the following fields:\n\npixels: array of pixels\nresolution: instance of a Resolution object\n\nYou can construct a map using one of the following forms:\n\nMap{T, O, AA}(arr) and Map{T, O, AA}(nside::Number) will use AA as basetype\nMap{T, O}(arr) and Map{T, O}(nside::Number) will use Array{T, 1} as basetype\n\nExamples\n\nThe following example creates a map with NSIDE=32 in RING order, containing integer values starting from 1:\n\nmymap = Healpix.Map{Int64, Healpix.RingOrder}(1:Healpix.nside2npix(32))\n\nThe call to collect is required to convert the range in an array.\n\nThis example creates a map in NESTED order, with NSIDE=64, filled with zeroes:\n\nmymap = Healpix.Map{Float64, Healpix.NestedOrder}(64)\n\nFinally, the following examples show how to use SharedArray:\n\nusing SharedArrays\n\n# Create a map with all pixels set to zero\nmymap = Healpix.Map{Float64, Healpix.NestedOrder, SharedArray{Float64, 1}}(64)\n\n# Create a map and initialize pixel values with a SharedArray\npixels = SharedArray{Int64, 1}(1:12 |> collect)\nmymap = Healpix.Map{Int64, Healpix.RingOrder, SharedArray{Int64, 1}}(m)\n\n\n\n\n\n","category":"type"},{"location":"mapfunc/#Healpix.PolarizedMap","page":"Map functions","title":"Healpix.PolarizedMap","text":"mutable struct PolarizedMap{T, O <: Healpix.Order, AA <: AbstractArray{T, 1}}\n\nA polarized I/Q/U map. It contains three Healpix maps with the same NSIDE:\n\ni\nq\nu\n\nYou can create an instance of this type using the function PolarizedMap{T,O}, which comes in three flavours:\n\nPolarizedMap(i::Map{T,O,AA}, q::Map{T,O,AA}, u::Map{T,O,AA})\nPolarizedMap{T,O}(i::AbstractVector{T}, q::AbstractVector{T}, u::AbstractVector{T})\nPolarizedMap{T,O}(nside::Number)\n\n\n\n\n\n","category":"type"},{"location":"mapfunc/#Encoding-the-order","page":"Map functions","title":"Encoding the order","text":"","category":"section"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Healpix.jl distinguishes between RING and NEST orderings using Julia's typesystem. The abstract type Order has two descendeants, RingOrder and NestedOrder, which are used to instantiate objects of type Map. Applying the functions nest2ring and  ring2nest to maps converts those maps to the appropriate orders. In-place nest2ring! and ring2nest! versions are also  available.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Order\nRingOrder\nNestedOrder\nnest2ring(m_nest::Map{T, NestedOrder, AA}) where {T, AA}\nring2nest(m_ring::Map{T, RingOrder, AA}) where {T, AA}\nnest2ring!(m_ring_dst::Map{T, RingOrder, AAR}, \n  m_nest_src::Map{T, NestedOrder, AAN}) where {T, AAN, AAR}\nring2nest!(m_nest_dst::Map{T, NestedOrder, AAN}, \n  m_ring_src::Map{T, RingOrder, AAR}) where {T, AAR, AAN}","category":"page"},{"location":"mapfunc/#Healpix.Order","page":"Map functions","title":"Healpix.Order","text":"Abstract type representing the ordering of pixels in a Healpix map. See also RingOrder and NestedOrder.\n\n\n\n\n\n","category":"type"},{"location":"mapfunc/#Healpix.RingOrder","page":"Map functions","title":"Healpix.RingOrder","text":"The RingOrder type should be used when creating Map types in order to specify that the pixels in the map are sorted in ring ordering. (See also NestedOrder.)\n\n\n\n\n\n","category":"type"},{"location":"mapfunc/#Healpix.NestedOrder","page":"Map functions","title":"Healpix.NestedOrder","text":"The NestedOrder type should be used when creating Map types in order to specify that the pixels in the map are sorted in ring ordering. (See also RingOrder.)\n\n\n\n\n\n","category":"type"},{"location":"mapfunc/#Healpix.nest2ring-Union{Tuple{Map{T, NestedOrder, AA}}, Tuple{AA}, Tuple{T}} where {T, AA}","page":"Map functions","title":"Healpix.nest2ring","text":"nest2ring(m_nest::Map{T, NestedOrder, AA}) where {T, AA}\n\nConvert a map from nested to ring order. This version allocates a new array of the same array type as the input.\n\nArguments:\n\nm_nest::Map{T, NestedOrder, AA}: map of type NestedOrder\n\nReturns:\n\nMap{T, RingOrder, AA}: the input map converted to RingOrder\n\nExamples\n\njulia> m_nest = Map{Float64,NestedOrder}(rand(nside2npix(64)));\n\njulia> nest2ring(m_nest)\n49152-element Map{Float64, RingOrder, Vector{Float64}}:\n 0.4703834205807309\n ⋮\n 0.3945848051663148\n\n\n\n\n\n","category":"method"},{"location":"mapfunc/#Healpix.ring2nest-Union{Tuple{Map{T, RingOrder, AA}}, Tuple{AA}, Tuple{T}} where {T, AA}","page":"Map functions","title":"Healpix.ring2nest","text":"ring2nest(m_ring::Map{T, RingOrder, AA}) where {T, AA}\n\nConvert a map from ring to nested order. This version allocates a new array of the same array type as the input.\n\nArguments:\n\nm_ring::Map{T, RingOrder, AA}: map of type RingOrder\n\nReturns:\n\nMap{T, NestedOrder, AA}: the input map converted to NestedOrder\n\nExamples\n\njulia> m_ring = Map{Float64,RingOrder}(rand(nside2npix(64)));\n\njulia> ring2nest(m_ring)\n49152-element Map{Float64, NestedOrder, Vector{Float64}}:\n 0.0673134062168923\n ⋮\n 0.703460503535335\n\n\n\n\n\n","category":"method"},{"location":"mapfunc/#Healpix.nest2ring!-Union{Tuple{AAR}, Tuple{AAN}, Tuple{T}, Tuple{Map{T, RingOrder, AAR}, Map{T, NestedOrder, AAN}}} where {T, AAN, AAR}","page":"Map functions","title":"Healpix.nest2ring!","text":"nest2ring!(m_ring_dst::Map{T, RingOrder, AAR}, \n           m_nest_src::Map{T, NestedOrder, AAN}) where {T, AAN, AAR}\n\nConvert a map from nested to ring order. This version takes a nested map in the  second argument and writes it to the nested map provided in the first argument, following the standard Julia func!(dst, src) convention.\n\nArguments:\n\nm_ring_dst::Map{T, NestedOrder, AA}: map of type NestedOrder\nm_nest_src::Map{T, NestedOrder, AAN}: map of type RingOrder\n\nReturns:\n\nMap{T, RingOrder, AA}: the input map converted to RingOrder\n\nExamples\n\njulia> m_nest = Map{Float64,NestedOrder}(rand(nside2npix(64)));\n\njulia> m_ring = Map{Float64,RingOrder}(64);\n\njulia> nest2ring!(m_ring, m_nest)\n49152-element Map{Float64, RingOrder, Vector{Float64}}:\n 0.33681791815569895\n ⋮\n 0.9092457003948482\n\n\n\n\n\n","category":"method"},{"location":"mapfunc/#Healpix.ring2nest!-Union{Tuple{AAN}, Tuple{AAR}, Tuple{T}, Tuple{Map{T, NestedOrder, AAN}, Map{T, RingOrder, AAR}}} where {T, AAR, AAN}","page":"Map functions","title":"Healpix.ring2nest!","text":"ring2nest!(m_nest_dst::Map{T, NestedOrder, AAN}, \n           m_ring_src::Map{T, RingOrder, AAR}) where {T, AAR, AAN}\n\nConvert a map from ring to nested order. This version takes a nested map in the  second argument and writes it to the nested map provided in the first argument, following the standard Julia func!(dst, src) convention.\n\nArguments:\n\nm_nest_dst::Map{T, NestedOrder, AAN}: map of type RingOrder\nm_ring_src::Map{T, RingOrder, AA}: map of type RingOrder\n\nReturns:\n\nMap{T, NestedOrder, AA}: the input map converted to NestedOrder\n\nExamples\n\njulia> m_ring = Map{Float64,RingOrder}(rand(nside2npix(64)));\n\njulia> m_nest = Map{Float64,RingOrder}(64);\n\njulia> ring2nest!(m_nest, m_ring)\n49152-element Map{Float64, NestedOrder, Vector{Float64}}:\n 0.0673134062168923\n ⋮\n 0.703460503535335\n\n\n\n\n\n","category":"method"},{"location":"mapfunc/#Pixel-functions","page":"Map functions","title":"Pixel functions","text":"","category":"section"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"When working with maps, it is not needed to pick between ang2pixNest and ang2pixRing because a Map type already encodes the ordering. Functions pix2ang and ang2pix always choose the correct ordering, but they require a Map instead of a Resolution as their first argument.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"pix2ang\nang2pix","category":"page"},{"location":"mapfunc/#Healpix.pix2ang","page":"Map functions","title":"Healpix.pix2ang","text":"pix2ang{T, O <: Order}(map::Map{T, O}, ipix) -> (Float64, Float64)\npix2ang{T, O <: Order}(map::PolarizedMap{T, O}, ipix) -> (Float64, Float64)\n\nReturn the pair (theta, phi), where theta is the colatitude and phi the longitude of the direction of the pixel center with index ipix.\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/#Healpix.ang2pix","page":"Map functions","title":"Healpix.ang2pix","text":"ang2pix{T, O, AA}(map::Map{T, O}, theta, phi)\nang2pix{T, O, AA}(map::PolarizedMap{T, O}, theta, phi)\n\nConvert the direction specified by the colatitude theta (∈ [0, π]) and the longitude phi (∈ [0, 2π]) into the index of the pixel in the Healpix map map.\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/#Loading-and-saving-maps","page":"Map functions","title":"Loading and saving maps","text":"","category":"section"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Healpix.jl implements a number of functions to save maps in FITS files.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"saveToFITS","category":"page"},{"location":"mapfunc/#Healpix.saveToFITS","page":"Map functions","title":"Healpix.saveToFITS","text":"saveToFITS(map::Map{T, O}, filename::AbstractString, typechar=\"D\", unit=\"\", extname=\"MAP\") where {T <: Number, O <: Order}\nsaveToFITS(map::PolarizedMap{T, O}, filename::AbstractString, typechar=\"D\", unit=\"\", extname=\"MAP\") where {T <: Number, O <: Order}\n\nSave a map into a FITS file. The name of the file is specified in filename; if it begins with !, existing files will be overwritten without warning. The parameter typechar specifies the data type to be used in the FITS file: the default (D) will save 64-bit floating-point values. See the CFITSIO documentation for other values. The keyword unit specifies the measure unit used for the pixels in the map. The keyword extname specifies the name of the HDU where the map pixels will be written.\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Function savePixelsToFITS is a low-level function. It knows nothing about the ordering schema used for the pixels, so the caller should manually write the ORDERING keyword in the HDU header by itself.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"savePixelsToFITS","category":"page"},{"location":"mapfunc/#Healpix.savePixelsToFITS","page":"Map functions","title":"Healpix.savePixelsToFITS","text":"savePixelsToFITS(map::Map{T}, f::FITSIO.FITSFile, column) where {T <: Number}\n\nSave the pixels of map into the column with index/name column in the FITS file, which must have been already opened.\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"To load a map from a FITS file, you can use readMapFromFITS.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"readMapFromFITS","category":"page"},{"location":"mapfunc/#Healpix.readMapFromFITS","page":"Map functions","title":"Healpix.readMapFromFITS","text":"readMapFromFITS{T <: Number}(f::FITSIO.FITSFILE, column, t::Type{T})\nreadMapFromFITS{T <: Number}(fileName::String, column, t::Type{T})\n\nRead a Healpix map from the specified (1-base indexed) column in a FITS file. The values will be read as numbers of type T. If the code fails, FITSIO will raise an exception. (Refer to the FITSIO library for more information.)\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/#Testing-for-conformability","page":"Map functions","title":"Testing for conformability","text":"","category":"section"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"It often happens that two Healpix maps need to be combined together: for instance, pixels on a sky map might need to be masked using a sky mask, or one map might need to be subtracted from another one. «Conformability» means that the operation between the two maps can be done directly on the pixels, without oordering or resolution conversions. The function conformables checks this.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"using Healpix # hide\nm1 = Map{Float64, RingOrder}(1)\nm2 = Map{Float64, RingOrder}(1)\nm3 = Map{Float64, NestedOrder}(1)\nm4 = Map{Float64, NestedOrder}(2)\nconformables(m1, m2)\nconformables(m1, m3)\nconformables(m1, m4)","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"conformables","category":"page"},{"location":"mapfunc/#Healpix.conformables","page":"Map functions","title":"Healpix.conformables","text":"conformables{T, S, O1, O2}(map1::Map{T, O1, AA1},\n                           map2::Map{S, O2, AA2}) -> Bool\nconformables{T, S, O1, O2}(map1::PolarizedMap{T, O1, AA1},\n                           map2::PolarizedMap{S, O2, AA2}) -> Bool\n\nDetermine if two Healpix maps are \"conformables\", i.e., if their shape and ordering are the same. The array types AA1 and AA2 are not considered in testing conformability.\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/#Interpolation","page":"Map functions","title":"Interpolation","text":"","category":"section"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"The fact that a Healpix map is, well, pixelized means that there is a sharp boundary between adjacent pixels. This can lead to undesidable effects, and therefore Healpix.jl provides a function, interpolate, that returns the interpolated value of the map along some direction in the sky:","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"If the direction (θ, ɸ) passes through the center of a pixel, interpolate returns the value of the pixel itself;\nOtherwise, the value of the pixel and its neighbours will be interpolated using a linear function to return a weighted value.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"interpolate","category":"page"},{"location":"mapfunc/#Map-making","page":"Map functions","title":"Map-making","text":"","category":"section"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Map-making is the process of converting a time series of measurements into a sky map. The most basic form of map-making is the so-called \"binning\", where samples in the time stream falling within the same sky pixel are averaged. This map-making algorithm is strictly accurate only if the noise in the time stream is white.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Healpix.jl implements two functions to perform binning, tod2map and combinemaps!.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"tod2map\ncombinemaps!","category":"page"},{"location":"mapfunc/#Healpix.tod2map","page":"Map functions","title":"Healpix.tod2map","text":"tod2map{T,O}(pixidx, tod::Array{T}; nside=128) :: (map, hits)\n\nCreate a binned map for a TOD and return a tuple containing the map itself and the hit map.\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/#Healpix.combinemaps!","page":"Map functions","title":"Healpix.combinemaps!","text":"combinemaps{T, O, H}(destmap::Map{T, O}, desthitmap::Map{H, O}, othermap::Map{T, O}, otherhitmap::Map{H, O})\n\nSum \"othermap\" to \"destmap\", assuming that both maps have been produced by binning TODs. The parameters desthitmap and otherhitmap are the two hit maps. At the end of the call, destmap and desthitmap are updated.\n\n\n\n\n\n","category":"function"},{"location":"misc/","page":"Miscellanea","title":"Miscellanea","text":"DocTestSetup = quote\n    using Healpix\nend","category":"page"},{"location":"misc/#General-purpose-functions","page":"Miscellanea","title":"General-purpose functions","text":"","category":"section"},{"location":"misc/","page":"Miscellanea","title":"Miscellanea","text":"Healpix.jl implements a few generic functions that can be helpful when doing calculations on the sphere.","category":"page"},{"location":"misc/","page":"Miscellanea","title":"Miscellanea","text":"lat2colat\ncolat2lat","category":"page"},{"location":"misc/#Healpix.lat2colat","page":"Miscellanea","title":"Healpix.lat2colat","text":"lat2colat(x)    colat2lat(x)\n\nConvert colatitude into latitude and vice versa. Both x and the result are expressed in radians.\n\n\n\n\n\n","category":"function"},{"location":"misc/#Healpix.colat2lat","page":"Miscellanea","title":"Healpix.colat2lat","text":"lat2colat(x)    colat2lat(x)\n\nConvert colatitude into latitude and vice versa. Both x and the result are expressed in radians.\n\n\n\n\n\n","category":"function"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"DocTestSetup = quote\n    using Healpix\nend","category":"page"},{"location":"pixelfunc/#Pixel-functions","page":"Pixel functions","title":"Pixel functions","text":"","category":"section"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"In this section we document the functions that convert from a direction in the sky into a pixel index, and vice versa.","category":"page"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"First of all, Healpix.jl implements the most basic functions to convert between spherical and Cartesian coordinates. Note that Healpix uses co-latitude instead of latitude:","category":"page"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"using Healpix # hide\nang2vec(0.0, 0.0)\nvec2ang(0.0, 0.0, 1.0)","category":"page"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"More interesting functions return the index of the pixel on a Healpix-tessellated sphere. For these functions to work, you have to provide a Resolution object:","category":"page"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"res = Resolution(16)\nang2pixRing(res, π/2, 0)\nang2pixNest(res, π/2, 0)","category":"page"},{"location":"pixelfunc/#Ring-functions","page":"Pixel functions","title":"Ring functions","text":"","category":"section"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"The Healpix projection has the advantage of storing pixels along iso-latitude rings; this allows to implement efficient spherical-transform functions. Healpix.jl provides a number of functions that manage rings. Many of them use the RingInfo structure, which encodes details about a ring.","category":"page"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"RingInfo\ngetringinfo\ngetringinfo!\ngetinterpolRing","category":"page"},{"location":"pixelfunc/#Healpix.RingInfo","page":"Pixel functions","title":"Healpix.RingInfo","text":"RingInfo\n\nInformation about a ring of pixels, i.e., the set of pixels on a Healpix map which have the same colatitude. The type is \"mutable\", so that one object can begin reused many times without further memory allocations.\n\nThe list of fields defined in this structure is the following:\n\nring: an integer index, running from \nfirstPixIdx: index of the first pixel (using the RING scheme) belonging to this ring\nnumOfPixels: number of consecutive pixels within the ring\ncolatitude_rad: value of the colatitude for this ring (in radians)\nshifted: Boolean flag; it is true if the longitude of the first pixel in the ring is not zero.\n\nReferences\n\nSee also getringinfo! and getringinfo.\n\nExample\n\nimport Healpix\nres = Healpix.Resolution(256)\n\n# Show information about ring #10\nprint(getringinfo(res, 10))\n\n\n\n\n\n","category":"type"},{"location":"pixelfunc/#Healpix.getringinfo","page":"Pixel functions","title":"Healpix.getringinfo","text":"getringinfo(resol::Resolution, ring; kwargs...) :: RingInfo\n\nReturn a RingInfo structure containing information about the specified ring. For the list of accepted keyword arguments, see getringinfo!.\n\n\n\n\n\n","category":"function"},{"location":"pixelfunc/#Healpix.getringinfo!","page":"Pixel functions","title":"Healpix.getringinfo!","text":"getringinfo!(resol::Resolution, ring, ringinfo::RingInfo; full=true) :: RingInfo\n\nFill the RingInfo structure with information about the specified ring. If full is false, the field colatitude_rad (the most expensive in terms of computation) is set to NaN.\n\n\n\n\n\n","category":"function"},{"location":"pixelfunc/#Healpix.getinterpolRing","page":"Pixel functions","title":"Healpix.getinterpolRing","text":"getinterpolRing(resol::Resolution, θ, ϕ) -> (Array{Int,1}, Array{Float64, 1})\ngetinterpolRing!(resol::Resolution, θ, ϕ, pix, weights) -> (Array{Int,1}, Array{Float64, 1})\n\nReturn the indices and the weights of the four neighbour pixels for the given direction (θ, ϕ) in a map with the specified resolution.\n\nIf provided, the parameters pix and weights should point to two 4-element arrays of integers and floating-points, respectively. They can be reused in multiple calls to avoid heap allocations and speed up the code.\n\n\n\n\n\n","category":"function"},{"location":"pixelfunc/#Reference","page":"Pixel functions","title":"Reference","text":"","category":"section"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"ang2vec(theta, phi)\nvec2ang(x, y, z)\nang2pixNest(resol::Resolution, theta, phi)\nang2pixRing(resol::Resolution, theta, phi)\npix2angNest(resol::Resolution, pixel)\npix2angRing(resol::Resolution, pixel)\nring2nest(resol::Resolution, ipix)\nnest2ring(resol::Resolution, ipix)\npix2ringpos(resol::Resolution, pixel)\npix2xyfNest(resol::Resolution, ipix)\npix2xyfRing(resol::Resolution, ipix)\nxyf2pixNest(resol::Resolution, ix, iy, facenum)\nxyf2pixRing(resol::Resolution, ix, iy, facenum)\npix2zphiRing(res::Resolution, pix)\npix2zphiNest(res::Resolution, pix)","category":"page"},{"location":"pixelfunc/#Healpix.ang2vec-Tuple{Any, Any}","page":"Pixel functions","title":"Healpix.ang2vec","text":"ang2vec(theta, phi) -> Array{Float64}\n\nGiven a direction in the sky with colatitude theta and longitude phi (in radians), return an array of 3 elements containing the x, y, and z components of the one-length vector pointing to that direction.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.vec2ang-Tuple{Any, Any, Any}","page":"Pixel functions","title":"Healpix.vec2ang","text":"vec2ang(x, y, z) -> (Number, Number)\n\nGiven a vector (not necessarily normalized) whose Cartesian components are x, y, and z, return a pair (theta, phi) containing the colatitude theta and the longitude phi (in radians) of the direction in the sky the vector is pointing at.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.ang2pixNest-Tuple{Resolution, Any, Any}","page":"Pixel functions","title":"Healpix.ang2pixNest","text":"ang2pixNest(resol::Resolution, theta, phi) -> Integer\n\nReturn the index of the pixel which contains the point with coordinates (theta, the colatitude, and phi, the longitude), in radians, for a Healpix map with pixels in nested order. Note that pixel indexes are 1-based (this is Julia)!\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.ang2pixRing-Tuple{Resolution, Any, Any}","page":"Pixel functions","title":"Healpix.ang2pixRing","text":"ang2pixRing(resol::Resolution, theta, phi) -> Integer\n\nReturn the index of the pixel which contains the point with coordinates (theta, the colatitude, and phi, the longitude), in radians, for a Healpix map with pixels in ring order. Note that pixel indexes are 1-based (this is Julia)!\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.pix2angNest-Tuple{Resolution, Any}","page":"Pixel functions","title":"Healpix.pix2angNest","text":"pix2angNest(resol::Resolution, pixel) -> (Float64, Float64)\n\nGiven the (1-based) index of a pixel in a Healpix map in nested order, return a pair containing the (colatitude, longitude) angles corresponding to its center, both expressed in radians.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.pix2angRing-Tuple{Resolution, Any}","page":"Pixel functions","title":"Healpix.pix2angRing","text":"pix2angRing(resol::Resolution, pixel) -> (Float64, Float64)\n\nGiven the (1-based) index of a pixel in a Healpix map in ring order, return a pair containing the (colatitude, longitude) angles corresponding to its center, both expressed in radians.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.ring2nest-Tuple{Resolution, Any}","page":"Pixel functions","title":"Healpix.ring2nest","text":"ring2nest(resol::Resolution, ipix) :: Int\n\nConvert the number of a pixel from RING to NESTED scheme.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.nest2ring-Tuple{Resolution, Any}","page":"Pixel functions","title":"Healpix.nest2ring","text":"nest2ring(resol::Resolution, ipix) :: Int\n\nConvert the number of a pixel from NESTED to RING scheme.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.pix2ringpos-Tuple{Resolution, Any}","page":"Pixel functions","title":"Healpix.pix2ringpos","text":"pix2ringpos(resol::Resolution, pixel)\n\nGiven the (1-based) index of a pixel in a Healpix map in ring order, return a pair of numbers (n, i, j) whose meaning is the following:\n\nn can be one of the symbols :northcap, :equator, or :southcap, representing the region of the sky\ni is the ring index, from 1 to 4NSIDE - 1\nj is the pixel-in-ring index\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.pix2xyfNest-Tuple{Resolution, Any}","page":"Pixel functions","title":"Healpix.pix2xyfNest","text":"pix2xyfNest(resol::Resolution, ipix) :: (Int, Int, Int)\n\nConvert a pixel number into (x, y, face), using NESTED ordering.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.pix2xyfRing-Tuple{Resolution, Any}","page":"Pixel functions","title":"Healpix.pix2xyfRing","text":"pix2xyfRing(resol::Resolution, ipix) :: (Int, Int, Int)\n\nConvert a pixel number into (x, y, face), using RING ordering.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.xyf2pixNest-Tuple{Resolution, Any, Any, Any}","page":"Pixel functions","title":"Healpix.xyf2pixNest","text":"xyf2pixNest(resol::Resolution, ix, iy, facenum) :: Int\n\nConvert (x, y, face) into a pixel number, using NESTED ordering.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.xyf2pixRing-Tuple{Resolution, Any, Any, Any}","page":"Pixel functions","title":"Healpix.xyf2pixRing","text":"xyf2pixRing(resol::Resolution, ix, iy, facenum) :: Int\n\nConvert (x, y, face) into a pixel number, using RING ordering.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.pix2zphiRing-Tuple{Resolution, Any}","page":"Pixel functions","title":"Healpix.pix2zphiRing","text":"pix2zphiRing(res::Resolution, pix) -> (z, phi)\n\nCompute the angular coordinates z = cos(θ), ϕ of the center of the pixel with number pix, assuming the RING numbering scheme for pixels. Caution: this method is inaccurate near the poles at high resolutions.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.pix2zphiNest-Tuple{Resolution, Any}","page":"Pixel functions","title":"Healpix.pix2zphiNest","text":"pix2zphiNest(res::Resolution, pix) -> (z, phi)\n\nCompute the angular coordinates z = cos(θ), ϕ of the center of the pixel with number pix, assuming the NEST numbering scheme for pixels. Caution: this method is inaccurate near the poles at high resolutions.\n\n\n\n\n\n","category":"method"},{"location":"resolutions/","page":"Working with resolutions","title":"Working with resolutions","text":"DocTestSetup = quote\n    using Healpix\nend","category":"page"},{"location":"resolutions/#Working-with-resolutions","page":"Working with resolutions","title":"Working with resolutions","text":"","category":"section"},{"location":"resolutions/","page":"Working with resolutions","title":"Working with resolutions","text":"A Healpix tessellation is parametrized by a number, called NSIDE, which must be a positive power of 2. It is related to the number of pixels N in the maps by the simple equation N = 12 mathrmNSIDE^2, and it is therefore related to the resolution of the pixelization. Any function working on a Healpix tessellation needs to receive the value of NSIDE. Healpix.jl provides a wrapper around this parameter, the Resolution type, which internally keeps a number of precomputed coefficients to accelerate calculations.","category":"page"},{"location":"resolutions/","page":"Working with resolutions","title":"Working with resolutions","text":"The following example prints a table containing details about a few Healpix resolutions:","category":"page"},{"location":"resolutions/","page":"Working with resolutions","title":"Working with resolutions","text":"using Healpix # hide\nusing Printf\n\n@printf(\"%-6s\\t%-12s\\t%-12s\\t%-12s\\n\",\n        \"NSIDE\",\n        \"#pix\",\n        \"#pix per face\",\n        \"solid angle\")\nfor poweroftwo in [0, 1, 2, 3, 4, 5]\n    res = Resolution(2 ^ poweroftwo)\n    @printf(\"%6d\\t%12d\\t%12d\\t%12.4f\\n\",\n            res.nside,\n            res.numOfPixels,\n            res.pixelsPerFace,\n            4π / res.numOfPixels)\nend","category":"page"},{"location":"resolutions/","page":"Working with resolutions","title":"Working with resolutions","text":"Resolution\nResolution(nside::Integer)\nnsideok(nside::Integer)\nnside2npix(nside::Integer)\nnpix2nside(npix::Integer)\nnside2pixarea(nside::Integer)\nnside2resol(nside::Integer)","category":"page"},{"location":"resolutions/#Healpix.Resolution","page":"Working with resolutions","title":"Healpix.Resolution","text":"struct Resolution\n\nResolution objects are needed to perform a number of pixel-related functions, e.g., convert a direction into a pixel number and vice versa.\n\nThe fields of a Resolution object are the following:\n\nnside: the NSIDE parameter\nnsideTimesTwo: 2 * NSIDE\nnsideTimesFour: 4 * NSIDE\nnumOfPixels: number of pixels in the map\norder: order of the map\npixelsPerFace: number of pixels in each Healpix face\nncap\nfact2\nfact1\n\n\n\n\n\n","category":"type"},{"location":"resolutions/#Healpix.Resolution-Tuple{Integer}","page":"Working with resolutions","title":"Healpix.Resolution","text":"Resolution(nside) -> Resolution\n\nCreate a Resolution object, given a value for NSIDE.\n\n\n\n\n\n","category":"method"},{"location":"resolutions/#Healpix.nsideok-Tuple{Integer}","page":"Working with resolutions","title":"Healpix.nsideok","text":"nsideok(nside::Integer) -> Bool\n\nCheck whether nside is a valid NSIDE parameter.\n\n\n\n\n\n","category":"method"},{"location":"resolutions/#Healpix.nside2npix-Tuple{Integer}","page":"Working with resolutions","title":"Healpix.nside2npix","text":"nside2npix(nside::Integer) -> Integer\n\nReturn the number of pixels for a Healpix map with the specified NSIDE value. If NSIDE is not an integer power of two, the function throws a DomainError exception.\n\n\n\n\n\n","category":"method"},{"location":"resolutions/#Healpix.npix2nside-Tuple{Integer}","page":"Working with resolutions","title":"Healpix.npix2nside","text":"npix2nside(npix::Integer) -> Integer\n\nGiven the number of pixels in a Healpix map, return the NSIDE resolution parameter. If the number is invalid, throw a DomainError exception.\n\n\n\n\n\n","category":"method"},{"location":"resolutions/#Healpix.nside2pixarea-Tuple{Integer}","page":"Working with resolutions","title":"Healpix.nside2pixarea","text":"nside2pixarea(nside::Integer) -> Real\n\nReturn the solid angle of a pixel in a map with the specified NSIDE parameter. The result is expressed in steradians.\n\n\n\n\n\n","category":"method"},{"location":"resolutions/#Healpix.nside2resol-Tuple{Integer}","page":"Working with resolutions","title":"Healpix.nside2resol","text":"nside2resol(nside::Integer) -> Real\n\nReturn the approximate resolution of a map with the specified NSIDE. The resolution is expressed in radians, and it is the square root of the pixel size.\n\n\n\n\n\n","category":"method"},{"location":"visualization/#Visualization-functions","page":"Visualization","title":"Visualization functions","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Healpix.jl uses RecipesBase to display maps. You need to import Plots in order to display maps, using the plot functions.  Maps are internally treated as heatmaps, so your backend should support this kind of visualization: at the moment, this is true for GR, PlotLy and PyPlot.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"using Healpix\nusing Plots\ngr()  # Use the GR backend\n\nnside = 8\nm = Map{Float64, RingOrder}(nside)\nm.pixels[:] = 1:length(m.pixels)\nplot(m)\nsavefig(joinpath(\"images\", \"mollweide.png\")) # hide","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"A call to plot can provide two additional arguments:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"A carthographic projection (see below).\nA dictionary containing parameters to be used by the carthographic projection.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"The following example displays the same map in orthographic coordinates:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"plot(m, orthographic)\nsavefig(joinpath(\"images\", \"orthographic.png\")) # hide","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"visualization/#Cartographic-projections","page":"Visualization","title":"Cartographic projections","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Plotting is based on project, which takes a map as input and produces a 2-D bitmap containing a representation of the map suitable to be shown using Plots.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Although the easiest way to plot a map is to use plot, project might be suitable in those cases where you are just interested in a 2D bitmap. It requires a inverse projection function (mapping the 2D plane to a point on the sphere) and the size of the bitmap, and it returns three values:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"A 2-D bitmap containing the color level of each pixel. Unseen pixels (e.g., those falling outside the ellipse in a Mollweide projection) are marked as NaN, as well as unseen pixels;\nA 2-D bitmap of Bool values, telling which pixels in the map are masked, i.e., they are marked as UNSEEN, NaN or missing in the Healpix map;\nA Bool flag telling if there is any masked value in the mask (2nd return value, see above). This parameter is returned to optimize calls to plot, but it is obviously redundant.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Consider this example:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"using Healpix\n\nm = Map{Float64, RingOrder}(1)\n# Plot the map on a 20×20 bitmap using an\n# equirectangular projection\nimage, mask, maskflag = project(equiprojinv, m, 20, 20)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"A number of parameters can be passed to project, in order to taylor the representation. They must not be passed as keyword arguments, because this would clash with the way plot recipes work; instead, you must use a dictionary:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"# Return a 2-D bitmap of 16-bit floating-point values\nimage, _, _ = project(equiprojinv, m, 20, 20,\n                      Dict(:desttype => Float16))","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"The following dictionary keys are available:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":":desttype: type used for the pixels in the 2-D bitmap returned by project. Default is Float32;\n:unseen: the value marking pixels as unseen, i.e., masked. The default is -1.6375e+30, to preserve compatibility with other Healpix libraries.\n:center: currently this is used only with orthographic projections. It specifies the coordinates of the center of the image (colatitude and longitude, both in radians).","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"project","category":"page"},{"location":"visualization/#Healpix.project","page":"Visualization","title":"Healpix.project","text":"project(invprojfn, m::Map{T, O, AA}, bmpwidth, bmpheight; kwargs...)\n\nReturn a 2D bitmap (array) containing a cartographic projection of the map and a 2D bitmap containing a boolean mask. The size of the bitmap is bmpwidth×bmpheight pixels. The function projfn must be a function which accepts as input two parameters x and y (numbers between -1 and 1).\n\nThe following keywords can be used in the call:\n\ncenter: 2-tuple specifying the location (colatitude, longitude) of the sky point that is to be placed in the middle of the image (in radians)\nunseen: by default, Healpix maps use the value -1.6375e+30 to mark unseen pixels. You can specify a different value using this keyword. This should not be used in common applications.\n\nReturn a Array{Union{Missing, Float32}} containing the intensity of each pixel. Pixels falling outside the projection are marked as NaN, and unseen pixels are marked as missing.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Projection-functions","page":"Visualization","title":"Projection functions","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Functions mollweide, equirectangular, and orthographic can be passed as parameters to plot.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"mollweide\nequirectangular\northographic\northographic2\ngnomonic","category":"page"},{"location":"visualization/#Healpix.mollweide","page":"Visualization","title":"Healpix.mollweide","text":"mollweide(m::Map{T, O, AA}, projparams = Dict()) where {T <: Number, O, AA}\n\nHigh-level wrapper around project for Mollweide projections.\n\nThe following parameters can be set in the projparams dictionary:\n\nwidth: width of the image, in pixels (default: 720 pixels)\nheight: height of the image, in pixels; if not specified, it will be assumed to be equal to width\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Healpix.equirectangular","page":"Visualization","title":"Healpix.equirectangular","text":"equirectangular(m::Map{T,O,AA}; kwargs...) where {T <: Number, O, AA}\n\nHigh-level wrapper around project for equirectangular projections.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Healpix.orthographic","page":"Visualization","title":"Healpix.orthographic","text":"orthographic(m::Map{T,O}, projparams = Dict()) where {T <: Number,O <: Order}\n\nHigh-level wrapper around project for orthographic projections.\n\nThe following parameters can be set in the projparams dictionary:\n\nwidth: width of the image, in pixels (default: 720 pixels)\nheight: height of the image, in pixels; if not specified, it will be assumed to be equal to width\ncenter: position of the pixel in the middle of the left globe (latitude and longitude).\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Healpix.orthographic2","page":"Visualization","title":"Healpix.orthographic2","text":"orthographic2(m::Map{T, O, AA}, projparams = Dict()) where {T <: Number, O, AA}\n\nHigh-level wrapper around project for stereo orthographic projections.\n\nThe following parameters can be set in the projparams dictionary:\n\nwidth: width of the image, in pixels (default: 720 pixels)\nheight: height of the image, in pixels; if not specified, it will be assumed to be equal to width\ncenter: position of the pixel in the middle of the left globe (latitude and longitude). Default is (0, 0).\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Healpix.gnomonic","page":"Visualization","title":"Healpix.gnomonic","text":"gnomonic(m::Map{T, O, AA}, projparams = Dict()) where {T <: Number, O, AA}\n\nHigh-level wrapper around project for gnomonic projections.\n\nThe following parameters can be set in the projparams dictionary:\n\nwidth: width of the image, in pixels (default: 720 pixels)\nheight: height of the image, in pixels; if not specified, it will be assumed to be equal to width\ncenter: position and orientation of the pixel in the middle. It is a 3-element tuple containing:\nThe latitude of the pixel, in radians\nThe longitude of the pixel, in radians\nThe rotation to be applied to the image, in radians\nfov_rad: size of the image along the x and y axes, in radians (default: 15°)\n\nExample\n\nplot(m, gnomonic, Dict(:fov_rad = deg2rad(1.5), :center = (0, 0, deg2rad(45))))\n\n\n\n\n\n","category":"function"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"They are based on inverse projection functions, i.e., functions that take a ","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"mollweideprojinv\nequiprojinv\northoinv\northo2inv\ngnominv","category":"page"},{"location":"visualization/#Healpix.mollweideprojinv","page":"Visualization","title":"Healpix.mollweideprojinv","text":"mollweideprojinv(x, y)\n\nInverse Mollweide projection. Given a point (x, y) on the plane, with x ∈ [-1, 1], y ∈ [-1, 1], return a 3-tuple of type (Bool, Number, Number). The boolean specifies if (x, y) falls within the map (true) or not (false), the second and third arguments are the latitude and longitude in radians.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Healpix.equiprojinv","page":"Visualization","title":"Healpix.equiprojinv","text":"equiprojinv(x, y)\n\nInverse equirectangular projection. Given a point (x, y) on the plane [-1, 1] × [-1, 1], return a tuple (Bool, Number, Number) where the first Boolean is a flag telling if the point falls within the projection (true) or not (false), and the two numbers are the latitude and longitude in radians.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Healpix.orthoinv","page":"Visualization","title":"Healpix.orthoinv","text":"orthoinv(x, y, ϕ1, λ0)\n\nInverse orthographic projection centered on (ϕ1, λ0). Given a point (x, y) on the plane, with x ∈ [-1, 1], y ∈ [-1, 1], return a 3-tuple of type (Bool, Number, Number). The boolean specifies if (x, y) falls within the map (true) or not (false), the second and third arguments are the latitude and longitude in radians.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n    using Healpix\nend","category":"page"},{"location":"#Healpix.jl:-an-implementation-of-the-Healpix-tessellation-scheme-in-Julia","page":"Introduction","title":"Healpix.jl: an implementation of the Healpix tessellation scheme in Julia","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the documentation of the Healpix.jl package, an implementation of the Healpix spherical tessellation scheme written entirely in Julia.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This library is a work-in-progress: if you want something with more functionality, have a look at Libhealpix.jl, as it wraps the Healpix C++ library. This package has the main purpose of providing a Julia-only solution, so that it can easily be used on platforms not supported by the Healpix C++ library (e.g., Windows).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This library implements algorithms for converting directions into pixel indices and vice versa. It supports both RING and NESTED schemes, and it employs Julia's powerful type system to avoid mistaking one scheme in place of the other.","category":"page"},{"location":"#Documentation","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The documentation was built using Documenter.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Dates # hide\nprintln(\"Documentation built on $(now()) using Julia $(VERSION).\") # hide","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
