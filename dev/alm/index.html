<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Spherical harmonics · Healpix.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Healpix.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../resolutions/">Working with resolutions</a></li><li><a class="tocitem" href="../pixelfunc/">Pixel functions</a></li><li><a class="tocitem" href="../mapfunc/">Map functions</a></li><li class="is-active"><a class="tocitem" href>Spherical harmonics</a><ul class="internal"><li><a class="tocitem" href="#Converting-between-pixel-space-and-harmonic-space"><span>Converting between pixel space and harmonic space</span></a></li><li><a class="tocitem" href="#From-harmonic-coefficients-to-the-power-spectrum"><span>From harmonic coefficients to the power spectrum</span></a></li><li><a class="tocitem" href="#Loading-and-saving-harmonic-coefficients"><span>Loading and saving harmonic coefficients</span></a></li><li><a class="tocitem" href="#Full-Pixel-Weights"><span>Full Pixel Weights</span></a></li></ul></li><li><a class="tocitem" href="../visualization/">Visualization</a></li><li><a class="tocitem" href="../misc/">Miscellanea</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Spherical harmonics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Spherical harmonics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ziotom78/Healpix.jl/blob/master/docs/src/alm.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Spherical-harmonics"><a class="docs-heading-anchor" href="#Spherical-harmonics">Spherical harmonics</a><a id="Spherical-harmonics-1"></a><a class="docs-heading-anchor-permalink" href="#Spherical-harmonics" title="Permalink"></a></h1><p>Starting from version 2.4, Healpix.jl implements generalized Fourier transformations through the <code>libsharp</code> library, to convert a map from its pixel-space representation to its decomposition in spherical harmonics. This has multiple applications, the most relevant being the analysis of Cosmic Microwave Background maps and the efficient computation of convolution operators.</p><p>Everything revolves around the <a href="#Healpix.Alm"><code>Alm</code></a> type, which encodes a set of spherical harmonics and is thus conceptually equivalent to the concept of a <a href="../mapfunc/#Healpix.Map"><code>Map</code></a>, only living in the harmonic space:</p><article class="docstring"><header><a class="docstring-binding" id="Healpix.Alm" href="#Healpix.Alm"><code>Healpix.Alm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An array of harmonic coefficients (a_ℓm).</p><p>The type <code>T</code> is used for the value of each harmonic coefficient, and it must be a <code>Number</code> (one should however only use complex types for this). The type <code>AA</code> is used to store the array of coefficients; a typical choice is <code>Vector</code>.</p><p>A <code>Alm</code> type contains the following fields:</p><ul><li><code>alm</code>: the array of harmonic coefficients</li><li><code>lmax</code>: the maximum value for <span>$ℓ$</span></li><li><code>mmax</code>: the maximum value for <span>$m$</span></li><li><code>tval</code>: maximum number of <span>$m$</span> coefficients for the maximum <span>$ℓ$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/1377cb08c46706686ffc3b29f6bdd604c54a2944/src/alm.jl#L3-L19">source</a></section></article><p>In the general case, the number of coefficients in a spherical harmonic expansion is infinite. For obvious reasons, Healpix.jl only allows to store band-limited expansions. The function <a href="#Healpix.numberOfAlms"><code>numberOfAlms</code></a> returns the number of floating-point numbers used to store the expansion, as a function of the maximum value for <span>$\ell$</span> and <span>$m$</span>.</p><article class="docstring"><header><a class="docstring-binding" id="Healpix.numberOfAlms" href="#Healpix.numberOfAlms"><code>Healpix.numberOfAlms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">numberOfAlms(lmax::Integer, mmax::Integer) -&gt; Integer
numberOfAlms(lmax::Integer) -&gt; Integer</code></pre><p>Return the size of the array of complex numbers needed to store the a_lm coefficients in the range of ℓ and m specified by <code>lmax</code> and <code>mmax</code>. If <code>mmax</code> is not specified, it is assumed to be equal to <code>lmax</code>. If <code>lmax</code> and <code>mmax</code> are inconsistent or negative, a <code>DomainError</code> exception is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/1377cb08c46706686ffc3b29f6bdd604c54a2944/src/alm.jl#L42-L51">source</a></section></article><h2 id="Converting-between-pixel-space-and-harmonic-space"><a class="docs-heading-anchor" href="#Converting-between-pixel-space-and-harmonic-space">Converting between pixel space and harmonic space</a><a id="Converting-between-pixel-space-and-harmonic-space-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-between-pixel-space-and-harmonic-space" title="Permalink"></a></h2><p>Healpix.jl implements the four functions <a href="#Healpix.alm2map"><code>alm2map</code></a>, <a href="#Healpix.map2alm"><code>map2alm</code></a>, <a href="#Healpix.alm2map!"><code>alm2map!</code></a>, and <a href="#Healpix.map2alm!"><code>map2alm!</code></a> to convert a map from a pixel-space representation to the harmonic space and vice-versa. The functions ending with <code>!</code> are <em>mutating</em> functions, which means that they assume that the result must be saved in a preallocated variable; they are space- and time-efficient and should be used when you want your code to be performant, or when you plan to apply the same operation several times (e.g., in a Monte Carlo simulation).</p><p>Here is an example:</p><pre><code class="language-julia">using Random

# Ensure reproducibility by using a fixed seed
Random.seed!(1234)

nside = 8
m = Map{Float32,RingOrder}(nside)

# Initialize the pixels to random values in the 0…1 range
for i in 1:length(m)
    m[i] = rand(Float32)
end

alm = map2alm(m)

# Go back to pixel space
newm = alm2map(alm, nside)</code></pre><pre class="documenter-example-output">768-element Map{Float64, RingOrder, Vector{Float64}}:
  0.1652631874267924
  0.3618781044964514
 -0.0013815388023583064
  0.40084766002795
  0.2530007233310308
  0.7785956979193502
  0.43071187199759775
  0.9379452241907033
  0.7554174116102925
  0.6032735376338993
  ⋮
  0.44347259128908373
  0.42263793922526627
 -0.20520639215243272
  0.4165901675651938
  0.6860000214208772
  0.7211351759306383
  0.6707478409770005
  0.47791307158759333
  0.7109101053740821</pre><p>The variable <code>newm</code> is a map that is close enough to <code>m</code>, yet it is not exactly the same because of the approximations done by both <code>map2alm</code> and <code>alm2map</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Healpix.map2alm!" href="#Healpix.map2alm!"><code>Healpix.map2alm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map2alm!(map::Map{Float64, RingOrder, Array{Float64, 1}}, alm::Alm{ComplexF64, Array{ComplexF64, 1}}; niter::Integer=3)
map2alm!(map::PolarizedMap{Float64, RingOrder, Array{Float64, 1}}, alm::Array{Alm{ComplexF64, Array{ComplexF64, 1}},1};
    niter::Integer=3)</code></pre><p>This function performs a spherical harmonic transform on the map and places the results in the passed <code>alm</code> object. This function requires types derived from Float64, since it is done in-place.</p><p><strong>Arguments</strong></p><ul><li><p><code>map</code>: the map that must be decomposed in spherical harmonics. It can either be a <code>Map{Float64, RingOrder}</code> type (scalar map) or a <code>PolarizedMap{Float64, RingOrder}</code> type (polarized map).</p></li><li><p><code>alm::Alm{ComplexF64, Array{ComplexF64, 1}}</code>: the spherical harmonic coefficients to be written to.</p></li></ul><p><strong>Keywords</strong></p><ul><li><code>niter::Integer</code>: number of iterations of SHTs to perform, to enhance accuracy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/1377cb08c46706686ffc3b29f6bdd604c54a2944/src/sphtfunc.jl#L74-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Healpix.map2alm" href="#Healpix.map2alm"><code>Healpix.map2alm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map2alm(map::Map{Float64, RingOrder, AA};
    lmax=nothing, mmax=nothing, niter::Integer=3)
map2alm(m::Map{T, RingOrder, AA}; lmax=nothing, mmax=nothing,
    niter::Integer=3) where {T &lt;: Real, AA &lt;: AbstractArray{T, 1} }</code></pre><p>Compute the spherical harmonic coefficients of a map. To enhance precision, more iterations of the transforms can be performed by passing a nonzero <code>niter</code>. The underlying SHT library libsharp performs all calculations using <code>Cdouble</code> types, so all inputs are converted to types based on Float64.</p><p><strong>Arguments</strong></p><ul><li><code>map</code>: the map to decompose in spherical harmonics. It can either be a <code>Map{T, RingOrder, AA}</code> type (scalar map) or a <code>PolarizedMap{T, RingOrder, AA}</code> type (polarized map).</li></ul><p><strong>Keywords</strong></p><ul><li><p><code>lmax::Integer</code>: the maximum ℓ coefficient, will default to 3*nside-1 if not specified.</p></li><li><p><code>mmax::Integer</code>: the maximum m coefficient</p></li><li><p><code>niter::Integer</code>: number of SHT iterations, to enhance precision. Defaults to 3</p></li></ul><p><strong>Returns</strong></p><ul><li><code>Alm{ComplexF64, Array{ComplexF64, 1}}</code>: the spherical harmonic coefficients corresponding to the map</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/1377cb08c46706686ffc3b29f6bdd604c54a2944/src/sphtfunc.jl#L158-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Healpix.alm2map!" href="#Healpix.alm2map!"><code>Healpix.alm2map!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">alm2map!(alm::Alm{ComplexF64, Array{ComplexF64, 1}}, map::Map{Float64, RingOrder, Array{Float64, 1}})
alm2map!(alm::Array{Alm{ComplexF64, Array{ComplexF64, 1}},1}, map::PolarizedMap{Float64, RingOrder, Array{Float64, 1}})</code></pre><p>This function performs a spherical harmonic transform on the map and places the results in the passed <code>alm</code> object. This function requires types derived from Float64, since it is done in-place.</p><p><strong>Arguments</strong></p><ul><li><p><code>alm::Alm{ComplexF64, Array{ComplexF64, 1}}</code>: the spherical harmonic coefficients to perform the spherical harmonic transform on.</p></li><li><p><code>map</code>: the map that will contain the result. It can either be a <code>Map{Float64, RingOrder, Array{Float64, 1}}</code> type (scalar map) or a <code>PolarizedMap{Float64, RingOrder, Array{Float64, 1}}</code> (polarized map).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/1377cb08c46706686ffc3b29f6bdd604c54a2944/src/sphtfunc.jl#L257-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Healpix.alm2map" href="#Healpix.alm2map"><code>Healpix.alm2map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">alm2map(alm::Alm{ComplexF64, Array{Float64, 1}}, nside::Integer)
alm2map(alm::Alm{T, Array{T, 1}}, nside::Integer) where T
alm2map(alm::Array{Alm{ComplexF64, Array{ComplexF64, 1}},1}, nside::Integer)
alm2map(alms::Array{Alm{T, Array{T, 1}},1}, nside::Integer) where T</code></pre><p>Compute a map from spherical harmonic coefficients. The underlying SHT library libsharp performs all calculations in Cdouble, so all inputs are converted to types based on Float64.</p><p><strong>Arguments</strong></p><ul><li><code>alm</code>: the spherical harmonic coefficients to transform. If of type <code>Alm{T, Array{T, 1}}</code>, we assume a spin-0 spherical harmonic transform. If an array of <code>Alm</code> is passed, we assume that the components correspond to T, E, and B coefficients.</li></ul><p><strong>Keywords</strong></p><ul><li><code>nside::Integer</code>: Healpix resolution parameter</li></ul><p><strong>Returns</strong></p><ul><li><code>Map{Float64, RingOrder, Array{Float64, 1}}</code> or <code>PolarizedMap{Float64, RingOrder, Array{Float64, 1}}</code> depending on if the input alm is of type <code>Alm{T, Array{T, 1}}</code> or <code>Array{Alm{T, Array{T, 1}}}</code> respectively.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/1377cb08c46706686ffc3b29f6bdd604c54a2944/src/sphtfunc.jl#L326-L352">source</a></section></article><h2 id="From-harmonic-coefficients-to-the-power-spectrum"><a class="docs-heading-anchor" href="#From-harmonic-coefficients-to-the-power-spectrum">From harmonic coefficients to the power spectrum</a><a id="From-harmonic-coefficients-to-the-power-spectrum-1"></a><a class="docs-heading-anchor-permalink" href="#From-harmonic-coefficients-to-the-power-spectrum" title="Permalink"></a></h2><p>You can use the function <code>alm2cl</code> to convert a set of <span>$a_{\ell m}$</span> coefficients into the components <span>$C_\ell$</span> of the power spectrum.</p><article class="docstring"><header><a class="docstring-binding" id="Healpix.alm2cl" href="#Healpix.alm2cl"><code>Healpix.alm2cl</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">alm2cl(alm::Alm{Complex{T}}) where {T &lt;: Number}
alm2cl(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T &lt;: Number}</code></pre><p>Compute <span>$C_{\ell}$</span> from the spherical harmonic coefficients of one or two fields.</p><p><strong>Arguments</strong></p><ul><li><code>alm₁::Alm{Complex{T}}</code>: the spherical harmonic coefficients of the first field</li><li><code>alm₂::Alm{Complex{T}}</code>: the spherical harmonic coefficients of the second field</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{T}</code> containing C_{ll}, with the first element referring to ℓ=0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/1377cb08c46706686ffc3b29f6bdd604c54a2944/src/alm.jl#L111-L124">source</a></section></article><h2 id="Loading-and-saving-harmonic-coefficients"><a class="docs-heading-anchor" href="#Loading-and-saving-harmonic-coefficients">Loading and saving harmonic coefficients</a><a id="Loading-and-saving-harmonic-coefficients-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-and-saving-harmonic-coefficients" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Healpix.readAlmFromFITS" href="#Healpix.readAlmFromFITS"><code>Healpix.readAlmFromFITS</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">readAlmFromFITS{T &lt;: Complex}(f::FITSIO.FITSFile, t::Type{T}) -&gt; Alm{T}
readAlmFromFITS{T &lt;: Complex}(fileName::String, t::Type{T}) -&gt; Alm{T}</code></pre><p>Read a set of a_ℓm coefficients from a FITS file. If the code fails, FITSIO will raise an exception. (Refer to the FITSIO library for more information.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/1377cb08c46706686ffc3b29f6bdd604c54a2944/src/alm.jl#L71-L78">source</a></section></article><h2 id="Full-Pixel-Weights"><a class="docs-heading-anchor" href="#Full-Pixel-Weights">Full Pixel Weights</a><a id="Full-Pixel-Weights-1"></a><a class="docs-heading-anchor-permalink" href="#Full-Pixel-Weights" title="Permalink"></a></h2><p>The default <a href="#Healpix.map2alm"><code>map2alm</code></a> uses iteration to obtain an accurate transform. One can instead apply a pixel weight to compute an accurate transform in a single pass, like quadrature. The easiest way to the pixel weight files is to run</p><pre><code class="language-none">git clone --depth 1 https://github.com/healpy/healpy-data</code></pre><p>These weights are in a compressed format that is read with <a href="@ref"><code>readfullweights</code></a> and multiplied into a map with <a href="@ref"><code>applyweights!</code></a>. </p><pre><code class="language-julia">nside = 32
compressed_weights = Healpix.readfullweights(
    &quot;healpix_full_weights_nside_$(lpad(nside,4,&#39;0&#39;)).fits&quot;)
m = Healpix.Map{Float64,Healpix.RingOrder}(ones(Healpix.nside2npix(nside)))
Healpix.applyweights!(m, compressed_weights)
alm = Healpix.map2alm(m; niter=0)</code></pre><p>The subsequent <a href="#Healpix.map2alm"><code>map2alm</code></a> only needs <code>niter=0</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Healpix.readfullweights" href="#Healpix.readfullweights"><code>Healpix.readfullweights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">readfullweights(filename::String)</code></pre><p>The easiest way to the pixel weight files is to run</p><pre><code class="language-none">git clone --depth 1 https://github.com/healpy/healpy-data</code></pre><p><strong>Arguments:</strong></p><ul><li><code>filename::String</code>: filename of the full pixel weights</li></ul><p><strong>Returns:</strong></p><ul><li><code>Vector{Float64}</code>: contains the compressed pixel weights</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/1377cb08c46706686ffc3b29f6bdd604c54a2944/src/weights.jl#L23-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Healpix.applyweights!" href="#Healpix.applyweights!"><code>Healpix.applyweights!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">applyweights!(m::Map{T, RingOrder}, wgt::Vector{T}) where T</code></pre><p>Apply a pixel weighting to a map for more accurate SHTs.</p><p><strong>Arguments:</strong></p><ul><li><code>m::Map{T, RingOrder}</code>: map to modify</li><li><code>wgt::Vector{T}</code>: compressed pixel weights</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/1377cb08c46706686ffc3b29f6bdd604c54a2944/src/weights.jl#L43-L51">source</a></section><section><div><pre><code class="language-none">applyweights!(m::PolarizedMap{T, RingOrder}, wgt::Vector{T}) where T</code></pre><p>Apply a pixel weighting to a polarized map for more accurate SHTs.</p><p><strong>Arguments:</strong></p><ul><li><code>m::PolarizedMap{T, RingOrder}</code>: map to modify</li><li><code>wgt::Vector{T}</code>: compressed pixel weights</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/1377cb08c46706686ffc3b29f6bdd604c54a2944/src/weights.jl#L77-L85">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mapfunc/">« Map functions</a><a class="docs-footer-nextpage" href="../visualization/">Visualization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 9 April 2021 09:15">Friday 9 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
